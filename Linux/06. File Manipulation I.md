## Timestamps

Every file in Linux maintains **three timestamps** that record different kinds of activity:
* **Access time (atime)** — updated when the file is read.
* **Modified time (mtime)** — updated when the file’s content changes.
* **Changed time (ctime)** — updated when file metadata changes (permissions, ownership, links, etc.).

### Viewing Timestamps

You can check these timestamps using `stat` or with `ls` options:
* `stat {file/directory}` — shows full timestamp details.
* `ls -l` — displays standard file listing with mtime.
* `ls -lt` — sort by modification time.
* `ls -lu` — show access time.
* `ls -ltu` — sort by atime.
* `ls -lc` — show and sort by change time.
* `ls -r/--reverse` — reverse sort

`ls` may shorten timestamps. To see the full format, use:
```
ls --full-time
```

### Changing Timestamps with `touch`

The `touch` command updates timestamps.
If the file doesn’t exist, `touch` creates it.
* `touch -a {file}` — update access time (this also updates ctime, because metadata changed).
* `touch -m {file}` — update modified time.
* `touch -m -t YYYYMMDDhhmmss {file}` — set mtime to a specific timestamp.
* `touch -a -t YYYYMMDDhhmmss {file}` — set atime to a specific timestamp.
* `touch -d "YYYY-MM-DD hh:mm:ss" {file}` — more readable date format.
* `touch {target_file} -r {reference_file}` — copy timestamps from one file to another.

### About ctime

You can’t directly modify **ctime**, because it updates automatically when metadata changes.
To indirectly influence it, you could adjust the **system clock** and then use:
```
touch {file}
```
This makes the file’s timestamps reflect whatever system time was set at that moment.

---
## File Types

Linux doesn’t rely on file extensions like `.txt` or `.png` to determine a file’s type.
Instead, it identifies files based on their **data headers** (the actual content).

Extensions exist mainly for **humans** and **GUI applications**.
So if you rename `video.mp4` to `video.txt`, the GUI won’t know how to open it with a double-click, but Linux still knows it’s a video internally.

* `file {file}` — displays the actual file type based on content.
* `file /path/*` — checks the type of every file in a directory.

### File Types with `ls -l`

The first character in `ls -l` output identifies the file type:
* `-` → regular file
* `d` → directory
* `l` → symbolic link
* `b` → block device
* `c` → character device
* `s` → socket
* `p` → named pipe (FIFO)

### File Classification with `ls -F`

`ls -F` adds symbols to filenames based on their type:
* `@` → symlink
* `/` → directory
* `=` → socket
* `|` → named pipe
* `*` → executable file

---
## Viewing Files

Most configuration on a Linux system lives inside plain text files. Network settings, user accounts, passwords (hashed), groups, services, logs—practically everything hides somewhere under `/etc`, `/var`, or the user’s home directory. Because of this, knowing how to view and navigate files is essential.

### `cat`
`cat` (concatenate) prints the contents of a file directly to standard output.
- `cat /path/to/file` displays the whole file.
- `cat -n file` adds line numbers to the output.
- You can combine files:  
    `cat file1 file2 > final_file`  
    This creates a new file containing both.

> `cat` is great for small files. For anything larger, pagination tools are easier to use.

### `less` and `more`
These are **pagers**, programs that let you scroll within long files.
- `less file` allows scrolling up and down, searching, and navigating large files comfortably.
- `more file` is more basic—scrolls forward only.

> `less` is the go-to when exploring long log files or configuration dumps.

### `tail`
`tail` shows the **end** of a file.
- `tail file` shows the last 10 lines.
- `tail -n 20 file` shows the last 20 lines.
- `tail -n +20 file` shows the file **starting from line 20** onward.
- `tail -f file` follows the file in real time.  
    Useful for watching logs as they grow.

### `head`
`head` is the mirror image of `tail`.  
`head file` shows the first 10 lines by default, or use `-n` to specify the number.

### `watch`
`watch` repeatedly runs a command and updates the screen at a set interval.
- `watch command` runs the command every 2 seconds.
- `watch -n 3 command` sets the interval to 3 seconds.
- `watch -d command` highlights changing output, which makes it especially handy for monitoring numbers, counts, or status changes.

---
## Creating, Copying, Moving, Removing Files and Directories

- as we discussed before we use `touch` to create file
- `mkdir` to create directory
- `mkdir -v` for verbose approach
- you can create several directories at once
- `mkdir -p` to create parent directory too

- `cp file1 file2` if file2 doesn't exist it copies file1 as file2. if it exists it overwrites file2 content with file1 content.
- `cp -v` verbose
- `cp -i` for prompt
- you can copy several files at once, last argument path gonna be destination.
- `cp -r` for recursive copy
- `cp -p` to preserve ownership of file

- `mv`  moves, renames and overwrites files and directories
- `mv -i` prompt
- `mv -n` automaticly  aborts  overwrite
- `mv -u` 

- `rm` removes files and directories
- `rm -i` prompt
- `rm -v` verbose
- `rm -r` recoursive
- `rm -f` force

- `shred` to delete files from storage too. cause `rm` just unlinks storage from file and makes it free. But `shred` completely deletes making it impossible to recover.
- `shred -vu -n 100 {file}`: v => verbose, u => remove after overwrite, -n {number} => amount of overwrite times.

> even shred may not be enough to keep secret, so keep your top-secret files encrypted.

> be careful to remove file or directory from terminal, cause there is no concept of trash bin in linux. it just disappears.

